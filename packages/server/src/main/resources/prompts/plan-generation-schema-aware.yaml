temperature: 0.5

activations:
  - role: system
    activation: plan-generation-schema-aware
    content: |
      {% verbatim %}
      Convert Prompt Schema (PS) to JSON DAG execution plan.
      
      ## PROCESS
      
      **Step 1: Read the Prompt Schema (PS)**
      The PS is a semantic representation of what the user wants:
      - `PS.filter[]`: Semantic intent to filter/restrict data
      - `PS.shape.group_by[]`: Semantic intent to group results
      - `PS.shape.aggregates[]`: Semantic intent to aggregate data (sum, count, etc.)
      - `PS.shape.order_by[]`: Semantic intent to sort results
      - `PS.shape.limit/offset`: Semantic intent to paginate results
      - `PS.params[]`: Additional parameters for the request
      
      **Step 2: Read the OpenAPI Specification**
      The operation's OpenAPI spec (provided in AVAILABLE OPERATIONS) shows:
      - How the API actually implements these semantic intents
      - Parameters section: path params, query params, headers
      - Input Schema (requestBody): request body structure
      - Required fields, field names, data types, operators supported
      
      **Step 3: Construct the HTTP Request**
      Convert semantic intent → actual HTTP request structure:
      - Map PS semantic fields to API's actual structure (check the spec!)
      - Map PS field names (snake_case) to API field names (check the spec!)
      - Determine where things go: path params, query params, or request body
      - Use placeholders for values: `{{filter.<field>.value}}`, `{{shape.limit}}`, etc.
      
      **Step 4: Encode into DAG Node**
      Encode the HTTP request into the DAG format:
      ```json
      {
        "start_node": {"vars": {}, "route": "api_call"},
        "api_call": {
          "operation": "exactOperationName",
          "http": {
            "path_params": {},
            "query": {},
            "headers": {},
            "body": {}
          },
          "route": "terminal"
        },
        "terminal": {
          "completed": true,
          "vars": {
            "answer": "$.['api_call'].['data']",
            "message": "Optional: Note if shaping was skipped"
          }
        }
      }
      ```
      
      ## KEY PRINCIPLES
      
      **Semantic → Syntactic Conversion**
      - PS is semantic (WHAT the user wants)
      - OpenAPI spec is syntactic (HOW the API implements it)
      - Your job: Convert semantic intent to API's actual structure
      - Don't assume - read the spec to see how filtering/grouping/aggregation is implemented
      
      **Field Name Mapping**
      - PS uses snake_case: `date_year_int`, `product_category`
      - API may use different format: `date.year`, `product.category`
      - Always check the operation schema for exact field names
      - Map PS field names to API field names based on the spec
      
      **Placeholders (Required for Caching)**
      - Filter values: `{{filter.<ps_field_name>.value}}`
      - Shape values: `{{shape.limit}}`, `{{shape.offset}}`
      - Param values: `{{params.<field_name>}}`
      - Never hardcode values - always use placeholders
      
      **Required Fields**
      - Check the operation's Input Schema for "required" array
      - ALL required fields must be included in the HTTP request
      - If required fields cannot be satisfied → return refusal plan
      
      **Unsupported Features**
      - If shaping (aggregates, order_by) not supported by API:
        → Omit the unsupported shaping from the request
        → Add message to terminal.vars explaining what was skipped
      - Only refuse if REQUIRED features (filter, fields) cannot be satisfied
      
      ## VALIDATION
      
      - [ ] Operation name matches exactly (case-sensitive) from available operations
      - [ ] All required fields from requestBody schema included
      - [ ] Field names mapped from PS (snake_case) to API format (check spec)
      - [ ] All values use placeholders (no hardcoded values)
      - [ ] HTTP request structure matches operation's OpenAPI definition
      - [ ] If shaping skipped, message added to terminal.vars
      
      Output ONLY valid JSON. Read PS (semantic), read OpenAPI spec (syntax), construct HTTP request, encode as DAG.
      {% endverbatim %}
      
  - role: user
    activation: plan-generation-schema-aware
    content: |
      Generate execution plan given the following inputs:
      
      ## AVAILABLE OPERATIONS
      ```json
      {{ operation_docs | raw }}
      ```
      
      ## PROMPT SCHEMA
      ```json
      {{ schema_json | raw }}
      ```
