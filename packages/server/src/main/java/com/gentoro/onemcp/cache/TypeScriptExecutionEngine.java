package com.gentoro.onemcp.cache;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.gentoro.onemcp.engine.OperationRegistry;
import com.gentoro.onemcp.exception.ExecutionException;
import com.gentoro.onemcp.plan.ExecutionPlan;
import com.gentoro.onemcp.utility.JacksonUtility;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Execution engine for TypeScript code generated by SQL planner (cache_spec v6.0).
 *
 * <p>Executes TypeScript code by:
 * 1. Creating a wrapper that provides an API client interface
 * 2. Transpiling/running TypeScript via Node.js
 * 3. Bridging API calls from TypeScript to Java OperationRegistry
 * 4. Returning execution results
 */
public class TypeScriptExecutionEngine {
  private static final org.slf4j.Logger log =
      com.gentoro.onemcp.logging.LoggingService.getLogger(TypeScriptExecutionEngine.class);

  private final OperationRegistry operationRegistry;
  private final ObjectMapper objectMapper = JacksonUtility.getJsonMapper();
  private final Path tempDir;
  private final com.gentoro.onemcp.OneMcp oneMcp;

  public TypeScriptExecutionEngine(OperationRegistry operationRegistry, Path tempDir) {
    this.operationRegistry = operationRegistry;
    this.tempDir = tempDir;
    this.oneMcp = null;
  }
  
  public TypeScriptExecutionEngine(OperationRegistry operationRegistry, Path tempDir, com.gentoro.onemcp.OneMcp oneMcp) {
    this.operationRegistry = operationRegistry;
    this.tempDir = tempDir;
    this.oneMcp = oneMcp;
  }

  /**
   * Convert TypeScript code to ExecutionPlan DAG format.
   * Parses the TypeScript to extract API calls and converts to ExecutionPlan structure.
   *
   * @param typescriptCode the TypeScript code (should export async function run(client))
   * @return ExecutionPlan that can be executed by ExecutionPlanEngine
   * @throws ExecutionException if conversion fails
   */
  public ExecutionPlan convertToExecutionPlan(String typescriptCode) throws ExecutionException {
    if (typescriptCode == null || typescriptCode.trim().isEmpty()) {
      throw new IllegalArgumentException("TypeScript code cannot be null or empty");
    }

    log.debug("Converting TypeScript to ExecutionPlan (length: {})", typescriptCode.length());

    try {
      // Parse TypeScript to extract API calls
      List<ApiCall> apiCalls = parseApiCalls(typescriptCode);
      
      if (apiCalls.isEmpty()) {
        throw new ExecutionException("No API calls found in TypeScript code");
      }

      // Convert to ExecutionPlan DAG
      ObjectNode planNode = objectMapper.createObjectNode();
      
      // Start node
      ObjectNode startNode = objectMapper.createObjectNode();
      startNode.set("vars", objectMapper.createObjectNode());
      startNode.put("route", apiCalls.size() == 1 ? "api_call_0" : "api_call_0");
      planNode.set("start_node", startNode);
      
      // Create nodes for each API call
      for (int i = 0; i < apiCalls.size(); i++) {
        ApiCall call = apiCalls.get(i);
        String nodeId = "api_call_" + i;
        String nextRoute = (i < apiCalls.size() - 1) ? "api_call_" + (i + 1) : "terminal";
        
        ObjectNode callNode = objectMapper.createObjectNode();
        callNode.put("operation", call.operationId);
        
        // Build HTTP request structure
        ObjectNode httpNode = objectMapper.createObjectNode();
        if (call.pathParams != null && !call.pathParams.isEmpty()) {
          ObjectNode pathParamsNode = objectMapper.createObjectNode();
          for (Map.Entry<String, String> entry : call.pathParams.entrySet()) {
            pathParamsNode.put(entry.getKey(), entry.getValue());
          }
          httpNode.set("path_params", pathParamsNode);
        }
        if (call.queryParams != null && !call.queryParams.isEmpty()) {
          ObjectNode queryNode = objectMapper.createObjectNode();
          for (Map.Entry<String, String> entry : call.queryParams.entrySet()) {
            queryNode.put(entry.getKey(), entry.getValue());
          }
          httpNode.set("query", queryNode);
        }
        if (call.body != null) {
          httpNode.set("body", objectMapper.valueToTree(call.body));
        }
        callNode.set("http", httpNode);
        callNode.put("route", nextRoute);
        
        planNode.set(nodeId, callNode);
      }
      
      // Terminal node
      ObjectNode terminalNode = objectMapper.createObjectNode();
      terminalNode.put("completed", true);
      ObjectNode terminalVars = objectMapper.createObjectNode();
      terminalVars.put("answer", "$.['api_call_" + (apiCalls.size() - 1) + "'].['data']");
      terminalNode.set("vars", terminalVars);
      planNode.set("terminal", terminalNode);
      
      ExecutionPlan plan = ExecutionPlan.fromNode(planNode);
      log.debug("Successfully converted TypeScript to ExecutionPlan with {} API calls", apiCalls.size());
      return plan;
      
    } catch (Exception e) {
      log.error("Failed to convert TypeScript to ExecutionPlan", e);
      throw new ExecutionException("Failed to convert TypeScript to ExecutionPlan: " + e.getMessage(), e);
    }
  }

  /**
   * Execute TypeScript code directly using Node.js and return the result.
   * This method executes TypeScript without converting to DAG.
   *
   * @param typescriptCode the TypeScript code to execute (should export async function run(client, values))
   * @param registry the operation registry for API calls
   * @param values the parameter values map from PS (key/value pairs for ? placeholders in S-SQL)
   * @return execution result as JSON string
   * @throws ExecutionException if execution fails
   */
  public String execute(String typescriptCode, OperationRegistry registry, Map<String, Object> values) throws ExecutionException {
    if (typescriptCode == null || typescriptCode.trim().isEmpty()) {
      throw new IllegalArgumentException("TypeScript code cannot be null or empty");
    }
    if (registry == null) {
      throw new IllegalArgumentException("OperationRegistry cannot be null");
    }
    
    log.debug("Executing TypeScript code directly (length: {})", typescriptCode.length());
    
    // Create temporary files
    String uuid = UUID.randomUUID().toString();
    Path bridgeFile = tempDir.resolve("bridge_" + uuid + ".js");
    Path jsFile = tempDir.resolve("code_" + uuid + ".js");
    Path resultFile = tempDir.resolve("result_" + uuid + ".json");
    
    try {
      // Ensure temp directory exists
      Files.createDirectories(tempDir);
      
      // Create package.json to ensure Node.js treats files as CommonJS (not ES modules)
      Path packageJson = tempDir.resolve("package.json");
      Files.writeString(packageJson, "{\"type\": \"commonjs\"}\n");
      
      // Set OperationRegistry in thread-local for HTTP bridge servlet
      // Get execution ID from inference logger if available, otherwise generate one
      String executionId = null;
      if (oneMcp != null && oneMcp.inferenceLogger() != null) {
        executionId = oneMcp.inferenceLogger().getCurrentExecutionId();
      }
      if (executionId == null || executionId.isEmpty()) {
        executionId = UUID.randomUUID().toString();
        log.debug("Generated new execution ID: {} for TypeScript execution", executionId);
      } else {
        log.debug("Using execution ID from inference logger: {} for TypeScript execution", executionId);
      }
      TypeScriptBridgeServlet.setExecutionId(executionId);
      TypeScriptBridgeServlet.setCurrentRegistry(registry);
      log.debug("OperationRegistry stored for execution ID: {}", executionId);
      try {
        // Create API client bridge that calls OperationRegistry
        // Pass execution ID so HTTP requests can find the registry
        String bridgeCode = createApiClientBridge(registry, resultFile, executionId);
        Files.writeString(bridgeFile, bridgeCode);
        
        // Wrap TypeScript code with execution harness and convert to JavaScript
        // Since we control the code generation, we can write it as plain JavaScript
        String wrappedCode = wrapTypeScriptCode(typescriptCode, bridgeFile.getFileName().toString(), resultFile.getFileName().toString(), bridgeFile, resultFile, values);
        
        // Write as .js file (not .ts) so we can use plain node without ts-node
        Files.writeString(jsFile, wrappedCode);
        
        // Execute using Node.js (plain JavaScript, no ts-node needed)
        String result = executeJavaScript(jsFile, bridgeFile, resultFile);
        
        log.debug("Successfully executed TypeScript code");
        return result;
      } finally {
        // Don't clear immediately - keep execution ID in map for a bit
        // to allow async HTTP requests from Node.js to complete
        // The execution ID will be cleaned up after execution completes
        // We use a longer delay to ensure all async requests finish
        String execId = TypeScriptBridgeServlet.getCurrentExecutionId();
        if (execId != null) {
          final String finalExecId = execId;
          // Clear after a delay to allow async HTTP requests to complete
          new Thread(() -> {
            try {
              Thread.sleep(5000); // Wait 5 seconds for async requests
              // Only clear if this execution ID is still in the map
              // (might have been cleared by another thread)
              if (TypeScriptBridgeServlet.executionRegistryMap.containsKey(finalExecId)) {
                TypeScriptBridgeServlet.executionRegistryMap.remove(finalExecId);
                log.debug("Cleaned up execution ID: {}", finalExecId);
              }
            } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
            }
          }).start();
        }
        // Clear thread-local immediately (but keep in map for async requests)
        TypeScriptBridgeServlet.clearThreadLocal();
      }
      
    } catch (Exception e) {
      log.error("Failed to execute TypeScript code", e);
      throw new ExecutionException("Failed to execute TypeScript code: " + e.getMessage(), e);
    } finally {
      // Clean up temporary files
      cleanupTempFiles(bridgeFile, jsFile, resultFile);
      // Note: Don't delete package.json as it might be used by other executions
    }
  }
  
  /**
   * Create API client bridge that provides TypeScript interface to Java OperationRegistry.
   * Uses HTTP to call a local endpoint that bridges to OperationRegistry.
   */
  private String createApiClientBridge(OperationRegistry registry, Path resultFile, String executionId) {
    // Get the server port from environment or use default
    String serverPort = System.getenv("SERVER_PORT");
    if (serverPort == null || serverPort.isBlank()) {
      serverPort = "8080";
    }
    String baseUrl = "http://localhost:" + serverPort;
    
    return String.format("""
        const http = require('http');
        const https = require('https');
        const { URL } = require('url');
        
        // API Client that bridges to Java OperationRegistry via HTTP
        class ApiClient {
          constructor(baseUrl) {
            this.baseUrl = baseUrl || '%s';
          }
          
          // Generic operation caller - calls local HTTP endpoint
          async call(operationId, params) {
            return new Promise((resolve, reject) => {
              const url = new URL(`${this.baseUrl}/api/execute-operation`);
              const postData = JSON.stringify({
                operationId: operationId,
                params: params || {},
                executionId: '%s'
              });
              
              const options = {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Content-Length': Buffer.byteLength(postData)
                }
              };
              
              const protocol = url.protocol === 'https:' ? https : http;
              const req = protocol.request(url, options, (res) => {
                let data = '';
                res.on('data', (chunk) => { data += chunk; });
                res.on('end', () => {
                  try {
                    const response = JSON.parse(data);
                    if (res.statusCode >= 400) {
                      reject(new Error(response.error || `HTTP ${res.statusCode}: ${data}`));
                    } else if (response.error) {
                      reject(new Error(response.error));
                    } else {
                      resolve(response.result || response);
                    }
                  } catch (e) {
                    reject(new Error(`Failed to parse response: ${e.message}`));
                  }
                });
              });
              
              req.on('error', (e) => {
                reject(new Error(`Request failed: ${e.message}`));
              });
              
              req.write(postData);
              req.end();
            });
          }
        }
        
        // Create client instance
        const client = new ApiClient('%s');
        
        // Export for use in TypeScript code
        module.exports = { client };
        """, baseUrl, executionId, baseUrl);
  }

  /**
   * Parse TypeScript code to extract API calls.
   * Looks for patterns like: await client.call('operationId', params)
   */
  private List<ApiCall> parseApiCalls(String typescriptCode) {
    List<ApiCall> calls = new ArrayList<>();
    
    // Pattern to match: await client.call('operationId', {...params...})
    // Also matches: client.call('operationId', {...params...})
    Pattern callPattern = Pattern.compile(
        "(?:await\\s+)?client\\.call\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*,\\s*([^)]+)\\)",
        Pattern.DOTALL
    );
    
    Matcher matcher = callPattern.matcher(typescriptCode);
    while (matcher.find()) {
      String operationId = matcher.group(1);
      String paramsStr = matcher.group(2).trim();
      
      try {
        // Parse params (could be object literal or variable)
        Map<String, String> pathParams = new HashMap<>();
        Map<String, String> queryParams = new HashMap<>();
        Object body = null;
        
        // Try to parse as JSON object
        if (paramsStr.startsWith("{") && paramsStr.endsWith("}")) {
          JsonNode paramsJson = objectMapper.readTree(paramsStr);
          
          // Extract path_params, query, body if present
          if (paramsJson.has("path_params")) {
            paramsJson.get("path_params").fields().forEachRemaining(entry -> {
              pathParams.put(entry.getKey(), entry.getValue().asText());
            });
          }
          if (paramsJson.has("query")) {
            paramsJson.get("query").fields().forEachRemaining(entry -> {
              queryParams.put(entry.getKey(), entry.getValue().asText());
            });
          }
          if (paramsJson.has("body")) {
            body = paramsJson.get("body");
          } else {
            // If no explicit structure, treat all params as query params
            paramsJson.fields().forEachRemaining(entry -> {
              if (!entry.getKey().equals("path_params") && !entry.getKey().equals("query")) {
                queryParams.put(entry.getKey(), entry.getValue().asText());
              }
            });
          }
        }
        
        calls.add(new ApiCall(operationId, pathParams, queryParams, body));
      } catch (Exception e) {
        log.warn("Failed to parse API call parameters: {}", paramsStr, e);
        // Create a basic call with operationId only
        calls.add(new ApiCall(operationId, new HashMap<>(), new HashMap<>(), null));
      }
    }
    
    return calls;
  }

  /**
   * Represents an API call extracted from TypeScript code.
   */
  private static class ApiCall {
    final String operationId;
    final Map<String, String> pathParams;
    final Map<String, String> queryParams;
    final Object body;

    ApiCall(String operationId, Map<String, String> pathParams, 
            Map<String, String> queryParams, Object body) {
      this.operationId = operationId;
      this.pathParams = pathParams != null ? pathParams : new HashMap<>();
      this.queryParams = queryParams != null ? queryParams : new HashMap<>();
      this.body = body;
    }
  }

  /**
   * Wrap TypeScript code with execution harness.
   * Converts ES module syntax (export) to CommonJS (module.exports).
   */
  private String wrapTypeScriptCode(String typescriptCode, String bridgeFileName, String resultFileName, Path bridgeFile, Path resultFile, Map<String, Object> values) {
    // Use relative paths since all files are in the same directory (tempDir)
    // This avoids path escaping issues with absolute paths
    String bridgePath = "./" + bridgeFileName;
    String resultPath = resultFile.getFileName().toString();
    
    // Convert ES module export to CommonJS
    // Replace "export async function run" with "async function run"
    // Then wrap it to assign to module.exports
    String commonJsCode = typescriptCode
        .replaceFirst("^export\\s+async\\s+function\\s+run", "async function run")
        .replaceFirst("^export\\s+function\\s+run", "function run");
    
    // Serialize values map to JSON for passing to the function
    String valuesJson = "{}";
    try {
      valuesJson = JacksonUtility.getJsonMapper().writeValueAsString(values != null ? values : java.util.Collections.emptyMap());
    } catch (Exception e) {
      log.warn("Failed to serialize values map, using empty object: {}", e.getMessage());
    }
    
    return String.format("""
        const { client } = require('%s');
        
        %s
        
        // Values array from PS (parameters for ? placeholders in S-SQL)
        const values = %s;
        
        // Execute and write result
        (async () => {
          try {
            const result = await run(client, values);
            const fs = require('fs');
            const path = require('path');
            fs.writeFileSync(
              path.join(__dirname, '%s'),
              JSON.stringify({ success: true, data: result })
            );
          } catch (error) {
            const fs = require('fs');
            const path = require('path');
            fs.writeFileSync(
              path.join(__dirname, '%s'),
              JSON.stringify({ success: false, error: error.message, stack: error.stack })
            );
          }
        })();
        """, bridgePath, commonJsCode, valuesJson, resultPath, resultPath);
  }

  /**
   * Transpile TypeScript to JavaScript.
   * Returns true if transpilation succeeded, false if we should use ts-node directly.
   */
  private boolean transpileTypeScript(Path tsFile, Path jsFile) throws IOException, InterruptedException {
    // Try to use tsc if available
    try {
      ProcessBuilder pb = new ProcessBuilder("tsc", "--target", "ES2020", "--module", "commonjs", tsFile.toString());
      pb.directory(tempDir.toFile());
      Process process = pb.start();
      boolean finished = process.waitFor(10, TimeUnit.SECONDS);
      
      if (finished && process.exitValue() == 0 && Files.exists(jsFile)) {
        log.debug("Successfully transpiled TypeScript to JavaScript");
        return true;
      }
    } catch (Exception e) {
      log.debug("tsc not available, will use ts-node: {}", e.getMessage());
    }
    
    return false;
  }

  /**
   * Execute JavaScript using Node.js.
   */
  private String executeJavaScript(Path codeFile, Path bridgeFile, Path resultFile) 
      throws IOException, InterruptedException, ExecutionException {
    
    // Always use plain node (codeFile should always be .js)
    String[] args = new String[]{"node", codeFile.toString()};
    
    ProcessBuilder pb = new ProcessBuilder(args);
    pb.directory(tempDir.toFile());
    pb.redirectErrorStream(true); // Redirect stderr to stdout
    
    Process process = pb.start();
    
    // Read output in a separate thread to avoid blocking
    StringBuilder output = new StringBuilder();
    Thread outputReader = new Thread(() -> {
      try (java.io.BufferedReader reader = new java.io.BufferedReader(
          new java.io.InputStreamReader(process.getInputStream()))) {
        String line;
        while ((line = reader.readLine()) != null) {
          output.append(line).append("\n");
        }
      } catch (IOException e) {
        log.debug("Error reading process output", e);
      }
    });
    outputReader.start();
    
    // Wait for execution (with timeout)
    boolean finished = process.waitFor(30, TimeUnit.SECONDS);
    
    if (!finished) {
      process.destroyForcibly();
      outputReader.interrupt();
      throw new ExecutionException("TypeScript execution timed out after 30 seconds");
    }
    
    // Wait for output reader to finish
    try {
      outputReader.join(1000);
    } catch (InterruptedException e) {
      // Ignore
    }
    
    if (process.exitValue() != 0) {
      String errorOutput = output.toString();
      if (errorOutput.isEmpty()) {
        errorOutput = "Process exited with code " + process.exitValue() + " but no error output";
      }
      log.error("TypeScript execution failed. Exit code: {}, Output: {}", process.exitValue(), errorOutput);
      throw new ExecutionException("TypeScript execution failed: " + errorOutput);
    }
    
    // Read result file
    if (!Files.exists(resultFile)) {
      throw new ExecutionException("TypeScript execution did not produce result file");
    }
    
    String resultContent = Files.readString(resultFile);
    JsonNode resultJson = objectMapper.readTree(resultContent);
    
    if (!resultJson.has("success") || !resultJson.get("success").asBoolean()) {
      String error = resultJson.has("error") ? resultJson.get("error").asText() : "Unknown error";
      throw new ExecutionException("TypeScript execution failed: " + error);
    }
    
    // Return the data as JSON string
    JsonNode data = resultJson.get("data");
    return data != null ? data.toString() : "{}";
  }

  /**
   * Clean up temporary files.
   */
  private void cleanupTempFiles(Path... files) {
    for (Path file : files) {
      try {
        if (Files.exists(file)) {
          Files.delete(file);
        }
      } catch (IOException e) {
        log.debug("Failed to delete temp file: {}", file, e);
      }
    }
  }
}

