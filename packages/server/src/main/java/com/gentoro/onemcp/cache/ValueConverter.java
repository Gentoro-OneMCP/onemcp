package com.gentoro.onemcp.cache;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.gentoro.onemcp.utility.JacksonUtility;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Converts PS values from conceptual space to API-consumable formats.
 * 
 * <p>Uses declarative conversion specs generated by the planner.
 * Supports standard transformations without code execution:
 * - Regex patterns (match/replace)
 * - Date/time formatting (Java DateTimeFormatter patterns)
 * - Type conversions (string→number, string→boolean)
 * - String templates
 */
public class ValueConverter {
  private static final org.slf4j.Logger log =
      com.gentoro.onemcp.logging.LoggingService.getLogger(ValueConverter.class);
  
  private final ObjectMapper mapper = JacksonUtility.getJsonMapper();

  /**
   * Convert PS values using conversion specs.
   * 
   * @param psValues original PS values: { "v1": "2024-12-06T14:30:00Z", ... }
   * @param conversionSpecs conversion specs: { "v1": { "type": "date_format", "pattern": "h:mm a" }, ... }
   * @return converted values: { "v1": "2:30 PM", ... }
   */
  public Map<String, Object> convert(Map<String, Object> psValues, Map<String, JsonNode> conversionSpecs) {
    if (psValues == null || psValues.isEmpty()) {
      return new HashMap<>();
    }
    
    Map<String, Object> converted = new HashMap<>();
    
    for (Map.Entry<String, Object> entry : psValues.entrySet()) {
      String label = entry.getKey();
      Object value = entry.getValue();
      JsonNode spec = conversionSpecs != null ? conversionSpecs.get(label) : null;
      
      if (spec == null || spec.isNull()) {
        // No conversion spec - use value as-is
        converted.put(label, value);
        continue;
      }
      
      try {
        Object convertedValue = applyConversion(value, spec);
        converted.put(label, convertedValue);
      } catch (Exception e) {
        log.warn("Failed to convert value {} with spec {}: {}", label, spec, e.getMessage());
        // Fallback: use original value
        converted.put(label, value);
      }
    }
    
    return converted;
  }

  /**
   * Apply a single conversion spec to a value.
   */
  private Object applyConversion(Object value, JsonNode spec) {
    if (value == null) {
      return null;
    }
    
    String type = spec.has("type") ? spec.get("type").asText() : null;
    if (type == null) {
      return value; // No conversion type specified
    }
    
    String strValue = value.toString();
    
    switch (type) {
      case "regex_replace":
        return applyRegexReplace(strValue, spec);
        
      case "regex_extract":
        return applyRegexExtract(strValue, spec);
        
      case "date_format":
        return applyDateFormat(strValue, spec);
        
      case "to_number":
        return applyToNumber(strValue);
        
      case "to_boolean":
        return applyToBoolean(strValue);
        
      case "string_template":
        return applyStringTemplate(strValue, spec);
        
      case "substring":
        return applySubstring(strValue, spec);
        
      case "uppercase":
        return strValue.toUpperCase();
        
      case "lowercase":
        return strValue.toLowerCase();
        
      case "trim":
        return strValue.trim();
        
      default:
        log.warn("Unknown conversion type: {}", type);
        return value;
    }
  }

  private String applyRegexReplace(String value, JsonNode spec) {
    String pattern = spec.has("pattern") ? spec.get("pattern").asText() : null;
    String replacement = spec.has("replacement") ? spec.get("replacement").asText() : null;
    
    if (pattern == null || replacement == null) {
      return value;
    }
    
    try {
      return value.replaceAll(pattern, replacement);
    } catch (Exception e) {
      log.warn("Regex replace failed: {}", e.getMessage());
      return value;
    }
  }

  private String applyRegexExtract(String value, JsonNode spec) {
    String pattern = spec.has("pattern") ? spec.get("pattern").asText() : null;
    int group = spec.has("group") ? spec.get("group").asInt(0) : 0;
    
    if (pattern == null) {
      return value;
    }
    
    try {
      Pattern p = Pattern.compile(pattern);
      Matcher m = p.matcher(value);
      if (m.find() && m.groupCount() >= group) {
        return m.group(group);
      }
      return value;
    } catch (Exception e) {
      log.warn("Regex extract failed: {}", e.getMessage());
      return value;
    }
  }

  private String applyDateFormat(String value, JsonNode spec) {
    String pattern = spec.has("pattern") ? spec.get("pattern").asText() : null;
    String inputFormat = spec.has("input_format") ? spec.get("input_format").asText() : "iso8601";
    
    if (pattern == null) {
      return value;
    }
    
    try {
      // Parse input date
      Instant instant = null;
      if ("iso8601".equals(inputFormat) || inputFormat == null) {
        instant = Instant.parse(value);
      } else {
        // Try to parse with specified input format
        DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern(inputFormat);
        LocalDateTime ldt = LocalDateTime.parse(value, inputFormatter);
        instant = ldt.atZone(ZoneId.systemDefault()).toInstant();
      }
      
      // Format output
      DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern(pattern);
      if (pattern.contains("h") || pattern.contains("H") || pattern.contains("m") || pattern.contains("s")) {
        // Time format
        LocalTime time = instant.atZone(ZoneId.systemDefault()).toLocalTime();
        return time.format(outputFormatter);
      } else if (pattern.contains("y") || pattern.contains("M") || pattern.contains("d")) {
        // Date format
        LocalDate date = instant.atZone(ZoneId.systemDefault()).toLocalDate();
        return date.format(outputFormatter);
      } else {
        // Full datetime
        LocalDateTime ldt = instant.atZone(ZoneId.systemDefault()).toLocalDateTime();
        return ldt.format(outputFormatter);
      }
    } catch (Exception e) {
      log.warn("Date format conversion failed: {}", e.getMessage());
      return value;
    }
  }

  private Number applyToNumber(String value) {
    try {
      if (value.contains(".")) {
        return Double.parseDouble(value);
      } else {
        return Long.parseLong(value);
      }
    } catch (NumberFormatException e) {
      log.warn("Failed to convert to number: {}", value);
      return 0;
    }
  }

  private Boolean applyToBoolean(String value) {
    return "true".equalsIgnoreCase(value) || "1".equals(value);
  }

  private String applyStringTemplate(String value, JsonNode spec) {
    String template = spec.has("template") ? spec.get("template").asText() : null;
    if (template == null) {
      return value;
    }
    
    // Simple template replacement: ${value} or {value}
    return template.replace("${value}", value).replace("{value}", value);
  }

  private String applySubstring(String value, JsonNode spec) {
    int start = spec.has("start") ? spec.get("start").asInt(0) : 0;
    int end = spec.has("end") ? spec.get("end").asInt(value.length()) : value.length();
    
    if (start < 0) start = 0;
    if (end > value.length()) end = value.length();
    if (start >= end) return "";
    
    return value.substring(start, end);
  }
}

