Below is Execution Plan Cache System — Specification v22A, identical to v22 but with alias support integrated cleanly and minimally, without altering any other architectural component.

No surrounding commentary — this is the full updated spec.

⸻

Execution Plan Cache System — Specification v22A

(Conceptual PS → Normalizer → Planner → DAG IR → ValueTransform DSL → Deterministic Executor)

⸻

0. Philosophy & Scope

This system converts natural language into API calls through:
	•	Prompt Schema (PS) — conceptual semantic grammar
	•	Normalizer — deterministic conversion from natural language to PS
	•	Planner — interprets PS + API metadata, generates DAG IR
	•	Value Transformation Section — deterministic conceptual→API conversions
	•	Executor — deterministic runtime

Conceptual Space and API Space remain separated. The planner is the only bridge.

⸻

1. End-to-End Pipeline

User Prompt
→ Normalizer
→ Prompt Schema (PS)
→ Planner
→ Execution Plan (DAG IR)
→ Executor
→ Backend APIs

⸻

2. Conceptual Lexicon

Domain-agnostic vocabulary.

{
  "actions": ["search", "create", "update", "delete"],

  "field_kinds": [
    "date_yyyy",
    "date_yyyy_mm",
    "date_yyyy_mm_dd",
    "date_quarter",
    "state_us_state_code",
    "state_name",
    "amount_decimal",
    "number",
    "integer",
    "boolean",
    "status",
    "color",
    "name",
    "id",
    "id_uuid"
  ],

  "filter_operators": [
    "equals",
    "not_equals",
    "contains",
    "starts_with",
    "ends_with",
    "greater_than",
    "greater_or_equal",
    "less_than",
    "less_or_equal",
    "before",
    "after",
    "between",
    "in",
    "not_in"
  ],

  "aggregates": [
    "sum",
    "avg",
    "min",
    "max",
    "count",
    "count_distinct"
  ],

  "structural": [
    "filter",
    "group_by",
    "order_by",
    "sort",
    "limit",
    "offset",
    "fields",
    "project",
    "select"
  ]
}


⸻

3. Deterministic Typed Normalization (DTN)

All conceptual values are deterministic strings or arrays of such strings:
	•	"2024", "2024-05", "2024-05-06", "2024-Q2"
	•	"123", "99.5"
	•	"true", "false"
	•	"CA", "New York"
	•	Arrays: ["CA", "NV", "OR"]

Value forms reflect conceptual meaning only.

⸻

4. Prompt Schema (PS)

Canonical conceptual structure:

{
  "action": "search",
  "entity": "sale",

  "filter": [
    {
      "field": "customer.state_us_state_code",
      "operator": "equals",
      "value": "CA"
    },
    {
      "field": "sale.status",
      "operator": "in",
      "value": ["open", "pending"]
    }
  ],

  "params": {
    "sale.date_yyyy_mm_dd": "2024-05-06"
  },

  "shape": {
    "group_by": ["customer.state_us_state_code"],
    "aggregates": [
      { "field": "sale.amount_decimal", "function": "sum" }
    ],
    "order_by": [
      { "field": "sale.amount_decimal", "direction": "desc" }
    ],
    "limit": "10",
    "offset": "0"
  }
}


⸻

5. Filter Clause Structure (Updated With Aliases)

Each filter entry has the structure:

{
  "field": "<conceptual_field_kind_or_qualified_field>",
  "operator": "<operator>",
  "value": "<scalar_or_array>",
  "alias": "<optional_identifier>"
}

Alias Semantics
	•	alias is an optional, PS-local identifier that distinguishes different uses of the same conceptual field.
	•	Aliases do not affect conceptual meaning, operator semantics, or cache keys.
	•	Aliases allow the planner to:
	•	Generate distinct valueTransforms for each usage.
	•	Bind values to distinct API-level parameters when required.

⸻

6. Alias Rules (Normalizer Behavior)

The normalizer applies these rules:
	1.	If the same conceptual field appears more than once in filter, the normalizer assigns a deterministic alias to each occurrence.
	2.	Aliases may be:
	•	Semantically derived ("start", "end"), or
	•	Automatically generated ("date#1", "date#2").
	3.	If a field appears only once, alias is omitted.
	4.	Alias presence does NOT change:
	•	The operator
	•	The conceptual field
	•	The conceptual value
	•	The cache key

Example:

{
  "field": "date_yyyy_mm_dd",
  "alias": "start",
  "operator": "greater_or_equal",
  "value": "2023-01-01"
},
{
  "field": "date_yyyy_mm_dd",
  "alias": "end",
  "operator": "less_or_equal",
  "value": "2023-12-31"
}

Both refer to the same conceptual field; aliases distinguish their roles.

⸻

7. Normalizer Rulebook

7.1 Operator Resolution
	•	"in", "one of", lists → "in"
	•	"not in" → "not_in"
	•	"before" → "before"
	•	"after" → "after"
	•	"greater than" → "greater_than"
	•	"less than" → "less_than"
	•	"contains" → "contains"
	•	Otherwise → "equals"

7.2 Value Cardinality Rules
	•	Single conceptual value → equals with scalar "value".
	•	Multiple conceptual values → in with array "value".
	•	Cardinality is never collapsed or unified.
	•	API requirements do not influence operator choice.

7.3 Field Resolution
	1.	Match conceptual reference to fields exposed in API dictionary.
	2.	Prefer fields local to PS entity.
	3.	Resolve ambiguous or invalid mappings via error.

7.4 Entity Resolution
	•	Prefer explicit mentions.
	•	Infer from fields when possible.
	•	Error on ambiguity.

7.5 Alias Creation
	•	If a conceptual field appears more than once in filters → assign aliases.
	•	Otherwise omit.

7.6 Ambiguity Handling

Normalizer errors on ambiguous field, entity, operator, or value interpretation.

⸻

8. API Metadata Schema

{
  "entities": {
    "sale": {
      "fields": {
        "amount": { "conceptual_kind": "amount_decimal", "supports": ["filter", "aggregate", "order"] },
        "status": { "conceptual_kind": "status", "supports": ["filter"] },
        "state": { "conceptual_kind": "state_us_state_code", "supports": ["filter"] },
        "created_at": { "conceptual_kind": "date_yyyy_mm_dd", "supports": ["filter", "order"] }
      },
      "operations": {
        "search": {
          "endpoint": "/sales",
          "method": "GET",
          "params_mode": "query",
          "supports": ["filter", "order", "pagination", "aggregation"]
        }
      }
    }
  }
}


⸻

9. Planner Rulebook

The planner converts PS into DAG IR using API metadata.

9.1 Field Mapping
	•	Each PS field maps to exactly one API field.
	•	If ambiguous or invalid → E_PARAM_NOT_MAPPABLE.

9.2 Operator Handling
	•	equals → scalar conceptual value.
	•	in → array conceptual value.
	•	Planner may convert scalar → array or array → repeated/combined formats only in API binding, not conceptually.

9.3 Handling Aliases
	•	If alias is present:
	•	Create a distinct valueTransform for that filter.
	•	Bind separately to API-level parameters (e.g. start_date and end_date).
	•	If alias omitted:
	•	One usage → one transform.
	•	Multiple usages with identical field but without alias is impossible due to normalizer rules.

Aliases affect only transform identity and API binding, not conceptual meaning.

9.4 ValueTransforms
	•	Scalars map to scalar transforms.
	•	Arrays map to array transforms using array_map and optional array_join.

9.5 ApiCall Construction
	•	Select API operation based on PS action.
	•	Bind API params or request body using transformed values.
	•	Cardinality chosen based on API metadata, independent of PS cardinality.

9.6 Shaping Node Construction
	•	group_by → Aggregate node
	•	aggregates → aggregate functions
	•	order_by → Sort node
	•	limit / offset → LimitOffset node
	•	fields → Project node

9.7 Error Semantics
	•	E_NO_API_PATH
	•	E_DAG_UNREALIZABLE
	•	E_API_SEMANTIC_CONSTRAINT
	•	E_PARAM_NOT_MAPPABLE
	•	E_AGGREGATE_UNSUPPORTED
	•	E_ORDERING_UNSUPPORTED
	•	E_BACKEND_LIMIT
	•	E_BACKEND_TIMEOUT
	•	E_BACKEND_UNAVAILABLE

⸻

10. DAG IR

(unchanged from v22.)

⸻

11. Value Transformation Section

(unchanged from v22.)

⸻

12. ValueTransform Operator Vocabulary

(unchanged from v22.)

⸻

13. Cache Keys

Cache key includes:
	•	action
	•	entity
	•	filter structure (field, operator, scalar vs array)
	•	params keys
	•	aggregates (field + function)
	•	group_by fields
	•	order_by fields
	•	presence of limit/offset

Cache key excludes:
	•	conceptual DTN values
	•	aliases
	•	API names and fields
	•	DAG structure
	•	transform steps
	•	CustomLogic code
	•	original prompt text

Aliases never affect cache keys.

⸻

14. Example Execution Plan

(unchanged from v22.)

⸻

15. Summary of v22A Additions
	•	Added alias field to PS filter objects.
	•	Normalizer assigns aliases when the same conceptual field appears multiple times.
	•	Planner uses aliases to create distinct transforms and API bindings.
	•	Aliases do not affect conceptual semantics or cache keys.

⸻

If you’d like, I can now generate v23 with the equals/in cardinality rules clarified in the Normalizer and Planner sections, fully harmonized with alias semantics.